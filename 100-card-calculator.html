<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>100-Card Deck Probability Explorer</title>

  <!-- Chart.js pinned version -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>

  <style>
    :root {
      --color-primary: rgb(99, 102, 241);
      --color-secondary: rgb(236, 72, 153);
      --color-success: rgb(16, 185, 129);
    }
    body {
      font-family: system-ui, sans-serif;
      background: #f7f7f7;
      margin: 2rem;
    }
    .panel {
      background: white;
      max-width: 1200px;
      padding: 1.5rem 2rem;
      border-radius: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      display: grid;
      grid-template-columns: 220px 1fr;
      grid-template-rows: auto 1fr;
      gap: 1.5rem;
    }
    .panel > header {
      grid-column: 1 / -1;
    }
    .controls {
      display: flex;
      flex-direction: column;
    }
    .chart-container {
      min-height: 400px;
    }
    label {
      display: block;
      font-weight: 600;
      margin-top: 1.2rem;
    }
    input[type="range"] {
      width: 100%;
      margin-top: 0.5rem;
    }
    canvas {
      margin-top: 1.5rem;
    }
    .value-box {
      font-weight: 600;
      margin-left: 0.5rem;
      color: #333;
    }
  </style>
</head>

<body>
  <div class="panel">
    <header>
      <h2 style="margin: 0 0 0.25rem;">100-Card Deck Probability Explorer</h2>
      <p style="margin: 0; color: #666;">(Hopefully) useful for commander deck theorycrafting.</p>
    </header>

    <div class="controls">
      <label for="sliderK">Target Cards</label>
      <input id="sliderK" type="range" min="1" max="99" value="20" />
      <span><span id="valK" class="value-box">20</span> / 100</span>

      <label for="sliderExtra">Extra draws</label>
      <input id="sliderExtra" type="range" min="0" max="10" value="3" />
      <span id="valExtra" class="value-box">3</span>

      <div style="margin-top: 1.5rem; font-size: 0.95rem; line-height: 1.4;">
        <b>P(at least one target):</b><br />
        <span id="atLeastOne" style="font-size: 1.3rem; font-weight: 700;">â€“</span>
      </div>
    </div>

    <div class="chart-container">
      <canvas id="chart"></canvas>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      // Register datalabels plugin
      Chart.register(ChartDataLabels);

      // ---------- Constants ----------
      const DECK_SIZE = 100;
      const OPENING_HAND = 7;
      const MAX_EXTRA_DRAWS = 10;

      // ---------- DOM Elements ----------
      const elements = {
        sliderK: document.getElementById("sliderK"),
        sliderExtra: document.getElementById("sliderExtra"),
        valK: document.getElementById("valK"),
        valExtra: document.getElementById("valExtra"),
        atLeastOne: document.getElementById("atLeastOne"),
        ctx: document.getElementById("chart").getContext("2d"),
      };

      // ---------- Chart Instance ----------
      let chart = null;

      // ---------- Combinatorics ----------
      /**
       * Compute binomial coefficient C(n, k) using multiplicative formula.
       * Avoids factorial overflow for reasonable n.
       * @param {number} n - Total items
       * @param {number} k - Items to choose
       * @returns {number} C(n, k)
       */
      function binomial(n, k) {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        // Optimize by using smaller k
        if (k > n - k) k = n - k;
        let result = 1;
        for (let i = 0; i < k; i++) {
          result = (result * (n - i)) / (i + 1);
        }
        return result;
      }

      /**
       * Hypergeometric PMF: P(X = k)
       * Drawing n items from population N containing K successes.
       * @param {number} N - Population size
       * @param {number} K - Number of success states in population
       * @param {number} n - Number of draws
       * @param {number} k - Number of observed successes
       * @returns {number} Probability
       */
      function hypergeometricPmf(N, K, n, k) {
        return (binomial(K, k) * binomial(N - K, n - k)) / binomial(N, n);
      }

      /**
       * Compute P(X >= 1) for hypergeometric distribution.
       * @param {number} N - Population size
       * @param {number} K - Number of success states
       * @param {number} n - Number of draws
       * @returns {number} P(X >= 1) = 1 - P(X = 0)
       */
      function hypergeometricAtLeastOne(N, K, n) {
        return 1 - hypergeometricPmf(N, K, n, 0);
      }

      // ---------- Chart Configuration ----------
      const chartColors = {
        primary: "rgb(99, 102, 241)",
        primaryAlpha: "rgba(99, 102, 241, 0.18)",
        secondary: "rgb(236, 72, 153)",
        secondaryAlpha: "rgba(236, 72, 153, 0.18)",
        success: "rgb(16, 185, 129)",
        successAlpha: "rgba(16, 185, 129, 0.18)",
      };

      const percentTickCallback = (value) => `${(value * 100).toFixed(1)}%`;

      // ---------- UI Update ----------
      function updateUI() {
        const K = Number.parseInt(elements.sliderK.value, 10);
        const extra = Number.parseInt(elements.sliderExtra.value, 10);

        elements.valK.textContent = K;
        elements.valExtra.textContent = extra;

        updateCharts(K, extra);
      }

      function updateCharts(K, extra) {
        const totalDraws = OPENING_HAND + extra;
        const maxSuccesses = Math.min(K, totalDraws);

        // X-axis: number of successes (0 to maxSuccesses)
        const labels = Array.from({ length: maxSuccesses + 1 }, (_, i) => i);

        // PMF: P(X = k) for total draws only
        const pmfTotal = labels.map((k) => hypergeometricPmf(DECK_SIZE, K, totalDraws, k));

        // Cumulative: P(X >= k) for total draws
        const cumulativeTotal = labels.map((k) => {
          let sum = 0;
          for (let i = k; i <= maxSuccesses; i++) {
            sum += hypergeometricPmf(DECK_SIZE, K, totalDraws, i);
          }
          return sum;
        });

        // Update "at least one" display
        const atLeast1Pct = cumulativeTotal[1] * 100; // P(X >= 1)
        elements.atLeastOne.textContent = `${atLeast1Pct.toFixed(2)}%`;

        // ----- Combined Chart -----
        if (chart) chart.destroy();
        chart = new Chart(elements.ctx, {
          type: "bar",
          data: {
            labels,
            datasets: [
              {
                type: "bar",
                label: `P(exactly k targets in ${totalDraws} cards)`,
                data: pmfTotal,
                backgroundColor: chartColors.secondaryAlpha,
                borderColor: chartColors.secondary,
                borderWidth: 1,
                order: 2,
              },
              {
                type: "line",
                label: `P(at least k targets in ${totalDraws} cards)`,
                data: cumulativeTotal,
                borderColor: chartColors.success,
                backgroundColor: "transparent",
                tension: 0.2,
                borderWidth: 3,
                pointRadius: 4,
                pointBackgroundColor: chartColors.success,
                order: 1,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              datalabels: {
                display: (context) => context.dataset.type === "bar",
                anchor: "end",
                align: "end",
                formatter: (value) => `${(value * 100).toFixed(0)}%`,
                font: { size: 11, weight: "bold" },
                color: chartColors.secondary,
              },
              tooltip: {
                filter: (context) => context.dataset.type === "line",
                displayColors: false,
                callbacks: {
                  title: () => "",
                  label: (context) => {
                    const pct = (context.raw * 100).toFixed(1);
                    const k = context.label;
                    return `${pct}% chance for at least ${k} targets`;
                  },
                },
              },
            },
            scales: {
              y: {
                title: { display: true, text: "Probability" },
                beginAtZero: true,
                max: 1,
                ticks: { callback: percentTickCallback },
              },
              x: {
                title: { display: true, text: "Cards" },
              },
            },
          },
        });
      }

      // ---------- Event Listeners ----------
      elements.sliderK.addEventListener("input", updateUI);
      elements.sliderExtra.addEventListener("input", updateUI);

      // ---------- Initialize ----------
      updateUI();
    })();
  </script>
</body>
</html>
